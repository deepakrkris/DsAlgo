**Is Unique:**
    - Implement an algorithm to determine if a string has all unique characters. What if you
    cannot use additional data structures? (1.1)


**Palindrome:**
    - Implement a function to check if a linked list is a palindrome


**Check Permutation:**
    - Given two strings, write a method to decide if one is a permutation of the other (1.2)


**Intersection**
    - Given two (singly) linked lists, determine if the two lists intersect. Return the intersecting node.
    Note that the intersection is defined based on reference, not value.
    That is, if the kth node of the first linked list is the exact same node (by reference)
    as the jth node of the second linked list, then they are intersecting.


**URLify:**
    - Write a method to replace all spaces in a string with '%20'
    - You may assume that the string has sufficient space at the end to hold the additional characters,
    and that you are given the "true" length of the string.
    (Note: If implementing in Java, please use a character array so that you can perform this operation in place.)
    
    - EXAMPLE
        - Input: "Mr John Smith "J 13
        - Output: "Mr%20J ohn%20Smith"
    (1.3)


**Loop Detection:** 
    - Given a circular linked list, implement an algorithm that returns the node at the
beginning of the loop. 
    DEFINITION  - Circular linked list: A (corrupt) linked list in which a node's next pointer points to an earlier node,
    so as to make a loop in the linked list.
    - EXAMPLE
         - Input: A -> B -> C -> 0 -> E -> C [loops in C]
         - Output: C


**Route Between Nodes:**
    - Given a directed graph, design an algorithm to find out whether there is a
route between two nodes.


**Minimal Tree:**
    - Given a sorted (increasing order) array with unique integer elements, write an algorithm to create a binary search tree with minimal height.


**List of Depths:**
    - Given a binary tree, design an algorithm which creates a linked list of all the nodes
at each depth (e.g., if you have a tree with depth 0, you'll have 0 linked lists).


**Check Balanced:**
    - Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.


**Validate BST:**
    - Implement a function to check if a binary tree is a binary search tree.


**Successor:**
    - Write an algorithm to find the "next" node (i.e., in-order successor) of a given node in a binary search tree. You may assume that each node has a link to its parent.
